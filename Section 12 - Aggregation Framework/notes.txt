Why do we need the Aggregation Framework?
    - Although we also attempt to store data in the way we intend to retrieve it, this is not alway possible.
    - The Aggregation Framework helps us to manipulate data to provide complex retrival methods
    - A customer facing app might have data scientist who need data in a particular format.
        - Not going to store the data in the format of a data sciencist (too complex)
        - We can use the Aggregation Framework to help retrieve the data in this format.

What is the Aggregation Framework?
    - Reference: https://www.mongodb.com/docs/manual/core/aggregation-pipeline/

    - The Aggregation Framework takes the form of a pipeline.
    - In each stage of the pipeline you can manipulate the data that is found.
    - 4 Stages
        - $match, $sort, $group, $project

Using $match
    - Reference: https://www.mongodb.com/docs/manual/reference/operator/aggregation/match/#mongodb-pipeline-pipe.-match

    - The match operator works very similarily to the find method.
    - It takes a document where you specify what values should be returned.
    - The aggregate method can take advantage of your indexes just like the find method can.

Using $group
    - Reference: https://www.mongodb.com/docs/manual/reference/operator/aggregation/group/#mongodb-pipeline-pipe.-group

    - The $group operator allows you to merge values from multiple documents into a single document.
    - The $group operator takes a document that defines the shape of the document returned.
    - _id is used to determine which field you want to group by.
        - The value for _id must be a document.
        - The first value in this document is the name you want for the returned document, the second is the field you want to group by.
        - When using a field from your collection it must start with a $.
            - "$dob.age"
    - Next define a field where you will store the result of an accumulator function.
    - Accumulator functions merge like documents into a single value.
        - $sum, $avg, $min, $max, ect.
    - Example { $group: { _id: { state: "$location.state" }, averageAge: { $avg: "$dob.age" } } }
    
Using $project
    - Reference: https://www.mongodb.com/docs/manual/reference/operator/aggregation/project/#mongodb-pipeline-pipe.-project

    - The $project stage is a great place to manipulate how your data looks and what is returned from your dataset.
    - Much like the project object in a find query you can omit a field by settings it's value to 0.
        - { _id: 0, "dob.age": 0 }
    - Similarly you can specify you only want to return a certain set of fields by setting their values to 1.
        - { _id: 0, "dob.age": 1 }
        - Only returns dob.age
    - The project stage in the aggregation pipeline is more powerful than the find queries.
        - You can use pipeline operators to change the way the data is returned.
        - Return the full name for a nested name document. 
        - Assume: { name: { first: 'Shane', Last: 'Kobylecky' } }
        - { $project: { fullName: $concat:["$name.first", " ", "$name.last" ] } }
            - Returns a fullName field with the values of name.first combined with name.last with a space in the middle.
            - There are SEVERAL pipeline operators.
            - Reference: https://www.mongodb.com/docs/manual/reference/operator/aggregation/

Using $push
    $push allows you to push elements into a new created array.

Using $unwind
    - Unwind can be used to create multiple documents when a document has an array field with multiple values.
    - A document is created for each array value. That document will have the same keys and values for all other fields. 
        - Similar to array.flat() in javascript.

Elimating duplicates
    - You can use $addToSet instead of $push to create unique arrays.
    - Each value is only pushed onto the new array if it is unqiue to that array.

Array Projection
    You can use array projection to manipulate array data into the form you need it to be in.

    - $slice - used to get chronological elements out of an array.
        - $slice: ["$myArray", 1] - Gets the first element from the array.
        - $slice: ["$myArray", 2, 1] - Starts at index 2 of the array and gets 1 element.
            - In this syntax you will retreive the third element from the array.
        - $slice ["$myArray", -2] - Starts at the end of the array and grabs the last two elements.

    -$filter - used to filter arrays based on some condition
        - Example: { $filter: { input: "$scoresArray", as: "score", cond: { gt: [$$score.grade, 60] } } }
            - input - The array field you want to filter through.
            - as - the name of each element that will run through the filter function
            - cond - an expression that resolves to true or false.

        - All values in the original array that pass the condition will be returned to a new array.

The $bucket stage
    - The bucket stage allows you to quickly group your data and report on those groupings.
        - groupBy - A field that allows you to group common data points together.
            - groupBy: "$dob.age"
        - boundaries - These are your buckets.
            - Specified as an array like [18, 30, 42, 54, 66]
        - output - the data you want to see for the buckets.
            - These are aggregation functions
            - numPersons: { $sum: 1 }
            - averageAge: { $avg: "$dob.age" }

    - Note: there is also an autoBucket stage which will automatically create buckets based on your data.
        - remove boundaries and add buckets.
        - buckets is the number of buckets you want mongo to create.
        - mongo will determine the best distribution points.

A few other Stages
    $limit - limits the number of results returned from the query.
    $skip - skips results from the current dataset.
        - $match, $skip, $limit should be in the correct order when used.
        - MongoDB has some optimization for this but it's typically pretty easy to order.
    $out - Pipes the data from the pipeline into a new collection or database and collection.
        { db: "myNewDB", coll: "myNewCollection" }
        - Note db is optional. If it's not specificed a new collection will be created in the current database.

One Note
    - Only the first stage has access to indexes.
    - Each additional stage only gets the output from stage 1.